--WEEK 2 MATERIAL

-----------------if else-----------------
divBy :: Int -> Int -> Bool
divBy a b =
    if b == 0
    then error ("Division by 0") -- Handling division by 0
    else if a `mod` b == 0
        then True
        else False
--main = print(divBy 10 2) -- True

ismult10 :: Int -> Bool
ismult10 x =
 if x `mod` 10 == 0
        then True
        else False
--main = print( ismult10 20 ) -- True

-----------------condition-----------------
powerrec :: Int -> Int -> Int
powerrec a b 
    | b==0 = 1             -- Any number to the power of 0 is 1
    | b > 0 = a * powerrec a (b - 1)  -- Recursive case
    |b<0 = error "Negative exponent"  -- Handle negative exponents
--main = print (powerrec 2 5)  -- Output: 32
sumpowers :: Int -> Int
sumpowers a 
    | a < 0     = error "Negative number"  
    | a == 0    = 0                         
    | a == 1    = 1                         
    | otherwise  = a ^ a + sumpowers (a - 1) 

--main = print(sumpowers 5) -- 3413

-----------------MISC-----------------
av5 :: Int -> Int -> Int -> Int -> Int -> Double
av5 a b c d e = fromIntegral (a + b + c + d + e) / 5.0
--main = print( av5 1 2 3 4 5) -- 3.0
--main = print(av5 3 5 7 9 10) -- 6.8

--{fromIntegral} is a function used to convert an integral type (like Int, Integer, etc.) 
--to a more general numeric type (like Float, Double, or any type that is an instance of the Num type class)

-----------------list comprehension-----------------

armstrong :: Int -> Bool
armstrong n = sum [x^length (show n) | x <- (map (\x -> read [x]) (show n))] == n
--main = print( armstrong 153) -- True
--main = print( armstrong 370) -- True
-- main = print( armstrong 0) -- True


--EXPLAIN ARMSTRONG:
---- Armstrong number
--  If sum of cubes of each digit of the number is equal to the number itself, then the number is called an   Armstrong number.
--  153 = 1^3 + 5^3 + 3^3
--  Given a positive integer number, write a function to determine whether it is an Armstrong number or not.
--show n : the show function is used to convert values of certain types into their string representation. (convert n to string)
--x^length (show n): x^length(x) in other language

--[expression | variable <- list]: list comprehension â†“
--[...|x <- (map (\x -> read [x]) (show n))] -> Here, x is a variable that takes on each value from the list generated by (map (\x -> read [x]) (show n))

--The map Function: map :: (a -> b) -> [a] -> [b]
--In our case, the type of a is Char (characters from the string) and the type of b is Int (the resulting integers).
--map applies this conversion to each character in the string, resulting in a list of digits: (map (\x -> read [x]) (show n))
--map takes two arguments:
--The lambda function (\x -> read [x]). The result of the transformation (after applying read) is Int.
--The list of characters obtained from (show n).

--lambda function: \x1 x2 ... xn -> expression
-- \x - define lambda
-- -> - separate param from body
-- read[x] - basically covert String to Int/Float/Double 
--aka: the given lambda function reading and evaluate each number. 